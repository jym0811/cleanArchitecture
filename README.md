# 계층형 아키텍쳐?

웹 → 도메인 → 영속성

1) Presentation(Web) Layer 

	- 사용자와의 Request, Response 등의 상호처리
	- View, Controller 등

2) Domain(Business) Layer

	- 소프트웨어가 해결하고자 하는 문제의 영역        →	   Domain ?
	- 도메인 처리에 초점을 둔 영역 				- 요구사항과 같은 해결하고자 하는 문제의 영역  
								- 게시글, 댓글, 결제기능 등

3) Persistence Layer

	- 엔티티를 영구히 저장하는 환경.		 →	   Entity ?	
								- 데이터의 집합
								- 저장되고 관리되어야 하는 데이터들
								- DB 테이블의 경우 레코드에 해당

	- 프로그램의 실행의 종료에도 데이터는 보존.


# 계층형 아키텍쳐의 특징

장점: 선택의 폭이 넓어지고 변화하는 요구사항과 외부요인에 빠르게 적응할 수 있게 해준다.
단점: 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 만든다.


# 계층형 아키텍쳐의 문제점

① 데이터베이스 주도 설계 유도
	- 웹은 도메인에 도메인은 영속성계층에 의존하므로 자연스레 데이터베이스에 의존 (ORM 프레임 워크의 사용이 원인)
	- 그동안 우리는 데이터베이스(영속성)의 구조를 먼저 생각하고 도메인 로직을 구현함
	- 계층형 아키텍쳐적 관점에서는 합리적이나 비즈니스 관점에서는 맞지 않음

	※ 도메인 로직을 가장 우선적으로 구현해야한다.


② 지름길을 택하기 쉬워진다.
	- 계층형 아키텍쳐에서 전체적으로 적용되는 규칙 → 특정한 계층에서는 같은 계층에 있는 컴포넌트나 아래 계층만 접근이 가능
	- 만약 상위 계층의 컴포넌트에 접근이 필요하다면, 컴포넌트를 아래 계층으로 내리면 된다. → 지름길
	- 지름길은 최선의 선택이 아니며, 빌드가 실패하는 결과를 초래한다.


③ 테스트하기 어려워진다.
	- 만약 엔티티의 필드를 하나만 조작하는 경우에는 도메인 로직을 구현할 필요가 없지 않을까? 
	
	위 방법대로 구현했을 경우에 문제점
	    1) 몇번은 괜찮아 보일 수 있으나 유스케이스가 확장된다면 애플리케이션 전체에 책임이 섞이고 핵심 도메인 로직들이 퍼질 확률이 높다.
	    2) 영속성 계층에서도 모킹이 필요하다. → 테스트의 복잡도가 향상 → 테스트 코드 작성시간보다 종속성 이해와 Mock 생성에 더 많은 시간 소요

            Mocking ?
	    - 테스트 코드가 의존하는 Function 이나 클래스의 모조품(Mock)을 만들어 일단 돌아가게 하는 것


④ 유스케이스를 숨긴다,
	- 도메인 로직이 여러 계층에 흩어지기 쉽다.
	- 새로운 기능을 추가할 적당한 위치를 찾는 일이 어려워진다.
	- 계층형 아키텍쳐는 서비스의 너비에 제한을 두지 않기 때문에 여러개의 유스케이스를 담당하는 넓은 서비스가 만들어지기도 하는데 → 영속성 계층에 너무 많은 의존성을 가지게 된다.

	Usecase?
	    사용자가 시스템을 사용하여 특정 목표를 달성하는 방법 ex) 자판기에서 음료를 산다.

⑤ 동시 작업이 어려워진다.
	- 계층형 아키텍쳐에서는 모든 것이 영속성 계층 위에 만들어지므로 영속성 계층을 먼저 개발하고 도메인 계층을 마지막으로 웹 계층을 만든다.
	- 특정 기능은 동시에 한 명의 개발자만 작업할 수 있으므로, 코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기 어려워지고
	  같은 서비스를 동시에 편집하게 되므로 conflict 를 야기한다.

	

# 단일 책임 원칙
- 하나의 컴포넌트는 오로지 한가지 일만 해야하고, 그것을 올바르게 수행해야한다.
- 책임은 오로지 한가지 일보다는 변경할 이유로 해석되어야 한다. → 변경할 이유가 한가지라면 소프트웨어가 여러번 변경되더라도 기대하는 결과값이 동일하므로

          Component?
	  시스템의 구성요소로 배포할 수 있는 가장 작은 단위
	  잘 설계된 컴포넌트라면 반드시 독립적으로 배포, 개발 가능해야 한다.


# 의존성 역전 원칙
	- 계층형 아키텍쳐에서 계층간 의존성은 다음 계층인 아래방향을 의미하는데 도메인 계층이 영속성 계층을 의존하므로 영속성 계층을 변경할 때마다 잠재적으로 도메인 계층을 변경해야한다.
	- 엔티티는 도메인 객체를 표현하고 도메인 코드는 엔티티의 상태를 변경하므로 먼저 영속성의 엔티티를 도메인 계층으로 올린다. 
	  → 영속성 계층의 리포지토리가 도메인 계층의 엔티티에 의존하므로 두 계층 사시에 순환 의존성이 생성된다. → 도메인 로직을 의존성으로부터 해방

	리포지터리(Repository)
	   - 유즈 케이스가 필요로 하는 데이터의 저장 및 수정 등의 기능을 제공하는 영역

# 클린 아키텍쳐
	- 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야함.
	- 계층 간의 모든 의존성이 안쪽으로 향해야 한다.
	- 코어(도메인 계층과 애플리케이션 계층을 합친 개념)에 주변 유스케이스에서 접근하는 도메인 엔티티 존재 → 넓은 서비스 문제 해결가능
	- 도메인코드에서는 어떤 영속성 프레임 워크나 UI 프레임워크가 사용되는지 알 수 없기 떄문에 비즈니스 로직에 집중 가능 → 도메인 코드의 자유로운 모델링 가능
	   → 하지만 도메인 계층이 영속성이 UI 같은 외부 계층과 철저히 분리돼야 하므로 엔티티에 대한 모델을 각 계층에서 보수해야함.

# 육각형 아키텍쳐 (헥사고날 아키텍쳐)
	- 애플리캐이션이 다른 시스템이나 어댑터와 연결되는 4개 이상의 면을 가질 수 있음.
	- 모든 의존성은 코어를 향한다.
	- 주도하는 어댑터는 그러한 포트가 코어에 있는 유스케이스 클래스 중 하나에 의해 구현되고 어댑터에 의해 호출.
	- 주도되는 어댑터는 그러한 포트가 어댑터에 의해 구현되고 코어에 의해 호출.
	- 마지막 계층에는 도메인 엔티티가 위치함.

클린 아키텍쳐, 헥사고날 아키텍쳐와 같은 방법으로 의존성을 역전시키는 이유는 변경할 이유를 줄여 유지소수성을 향상시키기 위함.

	



